# Load required packages
library(mice)
library(MASS)  # For multivariate normal distribution
library(miceDRF)
library(missForest)
library(ggplot2)
library(patchwork)
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
# BiocManager::install("impute")
library(impute)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("impute")
# Load required packages
library(mice)
library(MASS)  # For multivariate normal distribution
library(miceDRF)
library(missForest)
library(ggplot2)
library(patchwork)
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
# BiocManager::install("impute")
# Set seed for reproducibility
set.seed(123)
library(drf)
my_mice_rf <- function(data, m = 5, maxit = 5, ntree = 10,
rfPackage = c("ranger", "randomForest", "literanger"),
seed = NULL, saved_forests = NULL, ...) {
# Set seed if provided
if (!is.null(seed)) set.seed(seed)
# Match rfPackage argument
rfPackage <- match.arg(rfPackage)
# Find variables with missing values
vars_to_impute <- names(data)[colSums(is.na(data)) > 0]
# Initialize or use saved forests
if (is.null(saved_forests)) {
forests <- vector("list", length(vars_to_impute))
names(forests) <- vars_to_impute
fit_forests <- TRUE
} else {
forests <- saved_forests
fit_forests <- FALSE
}
# Create m imputed datasets
imputed_list <- vector("list", m)
for (imp in 1:m) {
# Start with original data
dat <- data
# Iterate maxit times
for (iter in 1:maxit) {
# Impute each variable
for (var in vars_to_impute) {
y <- dat[[var]]
ry <- !is.na(data[[var]])  # Use original missingness pattern
x <- as.matrix(dat[, setdiff(names(dat), var)])
wy <- !ry
xobs <- x[ry, , drop = FALSE]
xmis <- x[wy, , drop = FALSE]
yobs <- y[ry]
# Either fit new forest or use saved one
if (fit_forests && iter == maxit && imp == m) {
# Fit and save the forest
if (rfPackage == "ranger") {
forests[[var]] <- ranger::ranger(
y = yobs,
x = data.frame(xobs),  # Convert to data.frame
num.trees = ntree,
...
)
# Manually store training data
forests[[var]]$xobs <- xobs
forests[[var]]$yobs <- yobs
} else if (rfPackage == "randomForest") {
data_obs <- data.frame(y = yobs, xobs)
forests[[var]] <- randomForest::randomForest(
y ~ .,
data = data_obs,
ntree = ntree,
...
)
}
}
# Get donors
if (!is.null(saved_forests) && !is.null(saved_forests[[var]])) {
# Use saved forest to get donors
donor_matrix <- get_donors_from_forest(
forest = saved_forests[[var]],
xmis = xmis,
rfPackage = rfPackage
)
} else {
# Use mice internal functions (standard fitting)
f <- switch(rfPackage,
randomForest = mice:::.randomForest.donors,
ranger = mice:::.ranger.donors,
literanger = mice:::.literanger.donor)
donor_matrix <- f(xobs, xmis, yobs, ntree, ...)
}
# Sample imputations
nmis <- sum(wy)
if (nmis == 1)
donor_matrix <- array(donor_matrix, dim = c(1, ntree))
imputations <- apply(donor_matrix, MARGIN = 1, FUN = function(s) {
sample(unlist(s), 1)
})
# Fill in the imputations
dat[[var]][!ry] <- imputations
}
}
imputed_list[[imp]] <- dat
}
return(list(imputed_data = imputed_list, forests = forests))
}
get_donors_from_forest <- function(forest, xmis, rfPackage = c("ranger", "randomForest")) {
rfPackage <- match.arg(rfPackage)
if (rfPackage == "ranger") {
# Use manually stored training data
xobs <- forest$xobs
yobs <- forest$yobs
# IMPORTANT: Ensure column names match
if (!is.null(colnames(xobs)) && !is.null(colnames(xmis))) {
if (!all(colnames(xmis) == colnames(xobs))) {
# Reorder xmis columns to match xobs
xmis <- xmis[, colnames(xobs), drop = FALSE]
}
}
# Predict terminal nodes
pred_obs <- predict(forest, data = data.frame(xobs), type = "terminalNodes")
pred_mis <- predict(forest, data = data.frame(xmis), type = "terminalNodes")
nodes_obs <- pred_obs$predictions
nodes_mis <- pred_mis$predictions
ntree <- forest$num.trees
} else if (rfPackage == "randomForest") {
xobs <- forest$x
yobs <- forest$y
# IMPORTANT: Ensure column names match
if (!is.null(colnames(xobs)) && !is.null(colnames(xmis))) {
if (!all(colnames(xmis) == colnames(xobs))) {
xmis <- xmis[, colnames(xobs), drop = FALSE]
}
}
nodes_obs <- attr(predict(forest, newdata = xobs, nodes = TRUE), "nodes")
nodes_mis <- attr(predict(forest, newdata = xmis, nodes = TRUE), "nodes")
ntree <- forest$ntree
}
# Find donors
nmis <- nrow(xmis)
donor_matrix <- matrix(list(), nrow = nmis, ncol = ntree)
for (i in 1:nmis) {
for (j in 1:ntree) {
in_same_node <- nodes_obs[, j] == nodes_mis[i, j]
donor_matrix[i, j] <- list(yobs[in_same_node])
}
}
return(donor_matrix)
}
# Helper for NULL coalescing
`%||%` <- function(x, y) if (is.null(x)) y else x
get_results_sample_split <- function(data, method="DRF"){  # Introduce missingness in X1 when X2 > 0 with probability p_missing
d<-ncol(data)
train_indices <- sample(1:nrow(data), 0.5 * nrow(data))
train_set <- data[train_indices, ]
test_set <- data[-train_indices, ]
result_train <- my_mice_rf(
data = train_set,
m = 1,
maxit = 5,
ntree = 10,
rfPackage = "ranger",
seed = 123
)
saved_forests <- result_train$forests
# Step 2: Impute on different data using the SAME forests
result_test <- my_mice_rf(
data = test_set,
m = 1,
maxit = 5,
rfPackage = "ranger",
saved_forests = saved_forests,  # Use pre-fitted forests!
seed = 456
)
test_set_imp1<-result_test$imputed_data[[1]]
estimate1<- quantile(test_set_imp1[,1], probs=0.1) #unname(coefficients(lm(X2 ~ X1, data=test_set_imp1))[2])
#two folds
train_set <- data[-train_indices, ]
test_set <- data[train_indices, ]
result_train <- my_mice_rf(
data = train_set,
m = 1,
maxit = 5,
ntree = 10,
rfPackage = "ranger",
seed = 123
)
saved_forests <- result_train$forests
# Step 2: Impute on different data using the SAME forests
result_test <- my_mice_rf(
data = test_set,
m = 1,
maxit = 5,
rfPackage = "ranger",
saved_forests = saved_forests,  # Use pre-fitted forests!
seed = 456
)
test_set_imp2<-result_test$imputed_data[[1]]
estimate2<-quantile(test_set_imp2[,1], probs=0.1) #unname(coefficients(lm(X2 ~ X1, data=test_set_imp2))[2])
estimate<-1/2*(estimate1 + estimate2)
#estimate<-estimate1
# Extract results
return( list(estimate=estimate ) )
}
# Simulate from FGM Copula
# Method: Sample U1, then sample U2 | U1 from conditional distribution
# Function to sample U2 given U1 using inverse CDF method
sample_u2_given_u1 <- function(u1, alpha) {
# The conditional CDF is: F(u2|u1) = u2 + alpha*(2*u1-1)*(u2^2 - u2)
# We need to invert this to sample u2
# This is a quadratic equation: alpha*(2*u1-1)*u2^2 + [1 - alpha*(2*u1-1)]*u2 - v = 0
# where v ~ Uniform(0,1)
v <- runif(1)  # Sample from uniform
a <- alpha * (2*u1 - 1)
b <- 1 - alpha * (2*u1 - 1)
c <- -v
# Use quadratic formula: u2 = (-b + sqrt(b^2 - 4ac)) / (2a)
# We need the root in [0,1]
if (abs(a) < 1e-10) {
# Linear case (when u1 â‰ˆ 0.5)
u2 <- v / b
} else {
discriminant <- b^2 - 4*a*c
u2 <- (-b + sqrt(discriminant)) / (2*a)
}
return(u2)
}
# Simulation function
simulate_fgm <- function(n, alpha) {
# Step 1: Sample U1 from Uniform(0,1)
u1 <- runif(n)
# Step 2: Sample U2 | U1 for each u1
u2 <- sapply(u1, function(x) sample_u2_given_u1(x, alpha))
return(data.frame(U1 = u1, U2 = u2))
}
### Define Imputation Functions
#knn
impute_knn <- function(X) { return(impute.knn(as.matrix(X), colmax=0.99)$data) }
#missForest
impute_missForest <- function(X) { return(missForest(X)$ximp) }
# mice_cart
impute_mice_cart <-  miceDRF::create_mice_imputation("cart")
install.packages("miceDRF")
if (!requireNamespace("devtools", quietly = TRUE)) {
install.packages("devtools")
}
devtools::install_github("KrystynaGrzesiak/miceDRF")
